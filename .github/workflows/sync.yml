name: Build CDN Image Metadata

on:
  push:
    paths:
      - "images/**"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  metadata:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for git log history

      # NEW STEP: Fetch the previous metadata file from the 'output' branch
      - name: Fetch previous metadata
        id: fetch-prev
        continue-on-error: true
        run: |
          git fetch origin output:output || echo "Output branch not found, skipping fetch."
          # Try to read the file from the output branch and save it to root
          git show output:images-meta.json > prev-images-meta.json || echo "{}" > prev-images-meta.json

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y imagemagick

      - name: Generate metadata
        run: |
          node <<'EOF'
          const fs = require("fs");
          const path = require("path");
          const crypto = require("crypto");
          const { execSync } = require("child_process");

          const ROOT = "images";
          const OUT = "images-meta.json";
          const PREV_FILE = "prev-images-meta.json";
          const allowed = /\.(png|jpe?g|webp|bmp|tiff|gif|svg)$/i;

          // 1. Load Previous Metadata to preserve IDs and avoid expensive recalc
          let previousData = new Map();
          if (fs.existsSync(PREV_FILE)) {
            try {
              const content = fs.readFileSync(PREV_FILE, "utf8");
              if (content.trim()) {
                const json = JSON.parse(content);
                if (json.images && Array.isArray(json.images)) {
                  // Map by 'src' for easy lookup
                  json.images.forEach(img => previousData.set(img.src, img));
                }
              }
            } catch (err) {
              console.log("Warning: Could not parse previous metadata. Rebuilding all.");
            }
          }

          if (!fs.existsSync(ROOT)) {
            console.error(`Error: Directory "${ROOT}" not found.`);
            process.exit(1);
          }

          function walk(dir) {
            return fs.readdirSync(dir).flatMap(f => {
              const p = path.join(dir, f);
              return fs.statSync(p).isDirectory() ? walk(p) : p;
            }).filter(f => allowed.test(f));
          }

          function gitDate(file, first = false) {
            try {
              const cmd = first
                ? `git log --follow --diff-filter=A --format=%aI -- "${file}" | tail -1`
                : `git log -1 --format=%aI -- "${file}"`;
              const res = execSync(cmd).toString().trim();
              return res ? res.slice(0, 10) : new Date().toISOString().slice(0, 10);
            } catch {
              return new Date().toISOString().slice(0, 10);
            }
          }

          const files = walk(ROOT);
          const hashes = {};
          const images = [];

          console.log(`Processing ${files.length} files...`);

          for (const file of files) {
            const buf = fs.readFileSync(file);
            const hash = crypto.createHash("sha256").update(buf).digest("hex");
            const src = file.replace(/\\/g, "/");
            
            // Check if this file existed previously
            const prevEntry = previousData.get(src);
            
            // LOGIC: If path exists AND content hash is identical, reuse old data.
            // This prevents generating a new ID and skips slow Git/ImageMagick calls.
            if (prevEntry && prevEntry.hash === hash) {
              hashes[hash] = (hashes[hash] || 0) + 1;
              images.push(prevEntry);
              continue; // Skip to next file
            }

            // --- If we are here, it's a new file OR the content changed ---

            const stat = fs.statSync(file);
            const ext = path.extname(file).slice(1).toLowerCase();
            const relativePath = path.relative(ROOT, path.dirname(file));
            const folder = relativePath === "" ? "root" : relativePath.replace(/\\/g, "/");

            let dpi = "unknown", bit = "unknown";
            try {
              const r = execSync(`identify -format "%x|%z" "${file}"`)
                .toString().trim().split("|");
              dpi = r[0] || "unknown"; 
              bit = r[1] || "unknown";
            } catch {}

            hashes[hash] = (hashes[hash] || 0) + 1;
            
            // Calculate Git dates
            // If we have a prevEntry but hash changed, we keep 'added' date but update 'updated' date
            const addedDate = (prevEntry && prevEntry.dates && prevEntry.dates.added) 
                              ? prevEntry.dates.added 
                              : gitDate(file, true);

            images.push({
              id: hash.slice(0, 12),
              name: path.basename(file),
              src: src,
              folder,
              ext,
              dpi,
              bit_depth: bit,
              kb: +(stat.size / 1024).toFixed(2),
              hash,
              dates: {
                added: addedDate,
                updated: gitDate(file)
              }
            });
          }

          const duplicates = Object.values(hashes).filter(v => v > 1).length;
          const newTotal = images.length;

          const headerData = {
            version: 1,
            generated_at: new Date().toISOString(),
            total: newTotal,
            duplicates
          };

          let jsonOutput = JSON.stringify(headerData, null, 2);
          jsonOutput = jsonOutput.substring(0, jsonOutput.lastIndexOf("}"));
          const imageLines = images.map(img => `    ${JSON.stringify(img)}`);
          const imagesString = `,\n  "images": [\n${imageLines.join(",\n")}\n  ]\n}`;
          const finalContent = jsonOutput + imagesString;

          fs.writeFileSync(OUT, finalContent);
          
          console.log(`Processed ${newTotal} images.`);
          EOF

      - name: Deploy to Output Branch
        run: |
          cp images-meta.json /tmp/images-meta.json
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # We need to fetch/check output branch again to commit changes
          git fetch origin
          if git show-ref --verify --quiet refs/remotes/origin/output; then
            git checkout -f output
            git reset --hard origin/output
          else
            git checkout --orphan output
          fi
          
          git rm -rf . || true
          cp /tmp/images-meta.json images-meta.json
          
          git add images-meta.json
          git commit -m "chore: update cdn metadata [skip ci]" || echo "No changes to commit"
          git push origin output --force
